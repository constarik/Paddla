<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>PADDLA v0.5 - Provably Fair</title>
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TRP1QX4878"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-TRP1QX4878');
  </script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { overflow: hidden; height: 100%; touch-action: manipulation; }
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex; justify-content: center; align-items: center;
      font-family: Arial, sans-serif; color: white;
      flex-direction: column; gap: 8px;
    }
    h1 { color: #00d4ff; text-shadow: 0 0 20px rgba(0,212,255,0.5); font-size: 1.8rem; }
    .pf-badge { 
      background: rgba(0,255,100,0.2); border: 1px solid #00ff66; 
      padding: 3px 10px; border-radius: 10px; font-size: 11px; color: #00ff66;
      margin-left: 10px;
    }
    .game-container { position: relative; }
    canvas {
      border: 3px solid #00d4ff; border-radius: 10px;
      box-shadow: 0 0 30px rgba(0,212,255,0.3);
      cursor: none;
    }
    
    /* Timeout dots row */
    .timeout-row {
      display: flex; justify-content: center; gap: 15px; padding: 6px 0;
    }
    .timeout-dot {
      width: 18px; height: 18px; border-radius: 50%;
      background: #222; border: 2px solid #444;
      transition: all 0.3s;
    }
    .timeout-dot.active {
      background: radial-gradient(circle at 30% 30%, #ff6666, #ff0000);
      border-color: #ff4444;
      box-shadow: 0 0 12px #ff0000, 0 0 25px rgba(255,0,0,0.5);
      animation: pulse 0.3s ease-out;
    }
    
    .stats {
      display: flex; gap: 20px; font-size: 14px;
      background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 10px;
    }
    .stat { text-align: center; }
    .stat-value { font-size: 24px; font-weight: bold; color: #00d4ff; }
    .stat-label { font-size: 11px; color: rgba(255,255,255,0.7); }
    
    .progressive-lamps { display: flex; gap: 6px; align-items: center; }
    .lamp {
      width: 26px; height: 26px; border-radius: 50%;
      background: #333; border: 2px solid #555;
      display: flex; align-items: center; justify-content: center;
      font-size: 9px; font-weight: bold; color: #666;
      transition: all 0.3s;
    }
    .lamp.active {
      background: radial-gradient(circle at 30% 30%, #ffff00, #ff8800);
      border-color: #ffcc00; color: #000;
      box-shadow: 0 0 15px #ffcc00, 0 0 30px rgba(255,200,0,0.5);
      animation: pulse 0.5s ease-in-out;
    }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
    
    .controls {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;
    }
    .controls input, .controls select {
      padding: 8px; border-radius: 8px;
      border: 2px solid #00d4ff; background: rgba(0,0,0,0.5);
      color: #00d4ff; font-size: 14px; font-weight: bold; text-align: center;
    }
    .controls input { width: 70px; }
    .controls select { min-width: 120px; cursor: pointer; }
    .controls select option { background: #1a1a2e; }
    .controls button {
      padding: 10px 25px; font-size: 14px; font-weight: bold;
      background: linear-gradient(180deg, #00d4ff 0%, #0099cc 100%);
      color: #000; border: none; border-radius: 25px; cursor: pointer;
    }
    .controls button:disabled { background: #666; cursor: not-allowed; }
    .controls button:hover:not(:disabled) { transform: scale(1.05); }
    
    .info { font-size: 11px; color: rgba(255,255,255,0.4); text-align: center; }
    
    .result {
      display: none; position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%); background: rgba(0,0,0,0.95);
      padding: 25px 40px; border-radius: 15px; text-align: center;
      z-index: 50; border: 3px solid #00d4ff; max-width: 450px;
    }
    .result.show { display: block; }
    .result h2 { color: #00d4ff; font-size: 22px; }
    .result .amount { font-size: 42px; color: #4CAF50; margin: 8px 0; }
    .result .rtp { font-size: 13px; color: rgba(255,255,255,0.6); }
    .result .verify-section { 
      margin-top: 12px; padding-top: 12px; border-top: 1px solid #333;
      font-size: 10px; text-align: left; color: rgba(255,255,255,0.6);
    }
    .result .verify-section code {
      display: block; background: rgba(0,0,0,0.5); padding: 4px;
      border-radius: 5px; margin: 4px 0; word-break: break-all;
      font-family: monospace; font-size: 9px;
    }
    .result .verify-btn-result {
      margin-top: 8px; padding: 8px 20px; background: #00ff66;
      color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
    }
    .result .verify-btn-result:disabled { background: #666; cursor: wait; }
    
    .auto-results {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95); padding: 20px 30px; border-radius: 15px;
      border: 3px solid #00d4ff; z-index: 100; display: none; min-width: 300px;
    }
    .auto-results.show { display: block; }
    .auto-results h2 { color: #00d4ff; margin-bottom: 15px; text-align: center; }
    .auto-results table { width: 100%; border-collapse: collapse; }
    .auto-results th, .auto-results td { padding: 8px; text-align: center; border-bottom: 1px solid #333; }
    .auto-results th { color: #00d4ff; }
    .auto-results .best { color: #00ff66; font-weight: bold; }
    .auto-results .worst { color: #ff4444; }
    .auto-results .close-btn { margin-top: 15px; padding: 8px 20px; background: #00d4ff; color: #000; border: none; border-radius: 5px; cursor: pointer; width: 100%; }
    
    .mode-indicator {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      padding: 5px 15px; border-radius: 15px; font-size: 12px; font-weight: bold;
      background: rgba(255,165,0,0.3); border: 1px solid #ffa500; color: #ffcc00;
    }
    .mode-indicator.human { background: rgba(0,255,100,0.3); border-color: #00ff66; color: #00ff66; }
    
    .server-status {
      position: fixed; top: 10px; right: 10px; padding: 5px 10px;
      border-radius: 10px; font-size: 11px;
    }
    .server-status.online { background: rgba(0,255,100,0.2); border: 1px solid #00ff66; color: #00ff66; }
    .server-status.offline { background: rgba(255,0,0,0.2); border: 1px solid #ff4444; color: #ff4444; }
    
    .sound-btn {
      position: fixed; top: 10px; left: 10px; width: 40px; height: 40px;
      border-radius: 50%; border: 2px solid #00d4ff; background: rgba(0,0,0,0.5);
      font-size: 20px; cursor: pointer;
    }
    .sound-btn:hover { transform: scale(1.1); }
    .sound-btn.on { background: rgba(0,212,255,0.3); }
    
    /* Auth UI */
    .auth-panel {
      position: fixed; top: 10px; right: 120px;
      display: flex; align-items: center; gap: 10px;
    }
    .auth-btn {
      padding: 8px 16px; border-radius: 20px; border: 2px solid #00d4ff;
      background: rgba(0,0,0,0.5); color: #00d4ff; font-weight: bold;
      cursor: pointer; font-size: 12px;
    }
    .auth-btn:hover { background: rgba(0,212,255,0.2); }
    .auth-btn.google { border-color: #4285f4; color: #4285f4; }
    .user-info {
      display: flex; align-items: center; gap: 8px;
      padding: 5px 12px; background: rgba(0,0,0,0.5);
      border-radius: 20px; border: 1px solid #00ff66;
    }
    .user-avatar {
      width: 28px; height: 28px; border-radius: 50%;
      border: 2px solid #00ff66;
    }
    .user-name { color: #00ff66; font-size: 13px; font-weight: bold; }
    
    /* Nickname modal */
    .modal-overlay {
      display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); z-index: 200;
      justify-content: center; align-items: center;
    }
    .modal-overlay.show { display: flex; }
    .modal {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #00d4ff; border-radius: 15px;
      padding: 30px; text-align: center; max-width: 400px;
    }
    .modal h2 { color: #00d4ff; margin-bottom: 20px; }
    .modal input {
      width: 100%; padding: 12px; border-radius: 8px;
      border: 2px solid #00d4ff; background: rgba(0,0,0,0.5);
      color: #fff; font-size: 16px; text-align: center; margin-bottom: 15px;
    }
    .modal button {
      padding: 12px 30px; border-radius: 25px; border: none;
      background: linear-gradient(180deg, #00d4ff 0%, #0099cc 100%);
      color: #000; font-weight: bold; cursor: pointer; font-size: 14px;
    }
    .modal button:disabled { background: #666; cursor: not-allowed; }
    .modal .error { color: #ff4444; font-size: 12px; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="server-status offline" id="serverStatus">‚ö´ Offline</div>
  <button class="sound-btn" id="soundBtn" onclick="toggleSound()">üîá</button>
  
  <div class="auth-panel" id="authPanel">
    <button class="auth-btn google" id="loginBtn" onclick="signInWithGoogle()">üîë Sign In</button>
  </div>
  
  <!-- Nickname Modal -->
  <div class="modal-overlay" id="nicknameModal">
    <div class="modal">
      <h2>üéÆ Choose Your Nickname</h2>
      <input type="text" id="nicknameInput" placeholder="Enter nickname (3-15 chars)" maxlength="15">
      <button id="saveNicknameBtn" onclick="saveNickname()">SAVE</button>
      <div class="error" id="nicknameError"></div>
    </div>
  </div>
  
  <h1>üèì PADDLA <span class="pf-badge">üîí Provably Fair</span></h1>
  
  <div class="timeout-row" id="timeoutDots">
    <div class="timeout-dot"></div>
    <div class="timeout-dot"></div>
    <div class="timeout-dot"></div>
    <div class="timeout-dot"></div>
    <div class="timeout-dot"></div>
  </div>
  
  <div class="stats">
    <div class="stat">
      <div class="stat-value" id="ballsLeft">0</div>
      <div class="stat-label">BALLS</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="winDisplay">$0</div>
      <div class="stat-label">WIN</div>
    </div>
    <div class="stat">
      <div class="progressive-lamps" id="progressiveLamps">
        <div class="lamp">√ó1</div>
        <div class="lamp">√ó2</div>
        <div class="lamp">√ó3</div>
        <div class="lamp">√ó4</div>
        <div class="lamp">√ó5</div>
      </div>
      <div class="stat-label">MULTI</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="balance">$1000</div>
      <div class="stat-label">BALANCE</div>
    </div>
  </div>
  
  <div class="game-container">
    <canvas id="canvas" width="540" height="540"></canvas>
    <div class="mode-indicator human" id="modeIndicator">üëÜ HUMAN</div>
  </div>
  
  <div class="controls">
    <input type="number" id="ballCount" value="100" min="1" max="1000" step="50">
    <select id="modeSelect">
      <option value="human">üëÜ Human</option>
      <option value="stationary">üßç Stationary</option>
      <option value="hunter">üéØ Hunter</option>
      <option value="defender">üõ°Ô∏è Defender</option>
      <option value="sniper">üî´ Sniper</option>
      <option value="random">üé≤ Random</option>
      <option value="avoider">üèÉ Avoider</option>
    </select>
    <button id="playBtn">‚ñ∂ PLAY</button>
    <button id="autoBtn">AUTO √ó10</button>
  </div>
  
  <div class="info">Move bumper to direct balls into goals (top corners)</div>
  
  <div class="auto-results" id="autoResults">
    <h2>ü§ñ AUTO SIMULATION</h2>
    <div id="autoProgress"></div>
    <table id="autoTable"></table>
    <button class="close-btn" id="autoClose">CLOSE</button>
  </div>

  <div class="result" id="result">
    <h2>GAME OVER</h2>
    <div class="amount">$<span id="finalWin">0</span></div>
    <div class="rtp" id="finalRtp"></div>
    <div class="verify-section" id="verifySection">
      <strong>üîí Verification Data:</strong>
      <div>Game ID: <code id="vGameId"></code></div>
      <div>Client Seed: <code id="vClientSeed"></code></div>
      <div>Commitment: <code id="vCommitment"></code></div>
      <div>Server Seed: <code id="vServerSeed"></code></div>
      <button class="verify-btn-result" id="verifyBtn">‚úì VERIFY FAIRNESS</button>
      <div id="verifyResult" style="margin-top:10px;"></div>
    </div>
  </div>

<script>
// ===== FIREBASE CONFIG =====
const firebaseConfig = {
  apiKey: "AIzaSyA-dXCBeljE765qfaOBRtUlXLHBl26Y1tU",
  authDomain: "holepuncher-constr.firebaseapp.com",
  databaseURL: "https://holepuncher-constr-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "holepuncher-constr",
  storageBucket: "holepuncher-constr.firebasestorage.app",
  messagingSenderId: "356698016255",
  appId: "1:356698016255:web:913ed696aa4b3d17baffca",
  measurementId: "G-6C5X8BPRWP"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

// Set persistence to local
auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);

let currentUser = null;
let userData = null;

// ===== AUTH FUNCTIONS =====
async function signInWithGoogle() {
  try {
    const provider = new firebase.auth.GoogleAuthProvider();
    try {
      await auth.signInWithPopup(provider);
    } catch (popupError) {
      if (popupError.code === 'auth/popup-blocked' || popupError.code === 'auth/popup-closed-by-user') {
        await auth.signInWithRedirect(provider);
      } else {
        throw popupError;
      }
    }
  } catch (err) {
    console.error('Sign in failed:', err);
    alert('Sign in failed: ' + err.message);
  }
}

function signOut() {
  auth.signOut();
}

async function resetBalance() {
  if (!currentUser || !userData) return;
  if (!confirm('Reset balance to $1000?')) return;
  
  balance = 1000;
  const userRef = db.collection('paddla_users').doc(currentUser.uid);
  await userRef.update({ balance: 1000 });
  updateAuthUI();
  updateUI();
}

auth.onAuthStateChanged(async (user) => {
  currentUser = user;
  if (user) {
    const userRef = db.collection('paddla_users').doc(user.uid);
    const doc = await userRef.get();
    
    if (doc.exists) {
      userData = doc.data();
      balance = userData.balance || 1000;
      updateAuthUI();
      updateUI();
    } else {
      document.getElementById('nicknameModal').classList.add('show');
    }
  } else {
    userData = null;
    balance = 1000;
    updateAuthUI();
    updateUI();
  }
});

async function saveNickname() {
  const nickname = document.getElementById('nicknameInput').value.trim();
  const errorEl = document.getElementById('nicknameError');
  
  if (nickname.length < 3 || nickname.length > 15) {
    errorEl.textContent = 'Nickname must be 3-15 characters';
    return;
  }
  if (!/^[a-zA-Z0-9_]+$/.test(nickname)) {
    errorEl.textContent = 'Only letters, numbers and underscore allowed';
    return;
  }
  
  const existing = await db.collection('paddla_users').where('nickname', '==', nickname).get();
  if (!existing.empty) {
    errorEl.textContent = 'Nickname already taken';
    return;
  }
  
  const userRef = db.collection('paddla_users').doc(currentUser.uid);
  userData = {
    nickname,
    balance: 1000,
    gamesPlayed: 0,
    totalWon: 0,
    totalBet: 0,
    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    photoURL: currentUser.photoURL || null
  };
  await userRef.set(userData);
  
  balance = userData.balance;
  document.getElementById('nicknameModal').classList.remove('show');
  updateAuthUI();
  updateUI();
}

function updateAuthUI() {
  const panel = document.getElementById('authPanel');
  if (currentUser && userData) {
    panel.innerHTML = `
      <div class="user-info">
        ${userData.photoURL ? `<img class="user-avatar" src="${userData.photoURL}" alt="">` : ''}
        <span class="user-name">${userData.nickname}</span>
        <span style="color:#00d4ff;">${balance}</span>
      </div>
      <button class="auth-btn" onclick="resetBalance()" style="border-color:#ff6600;color:#ff6600;">Reset $</button>
      <button class="auth-btn" onclick="signOut()">Logout</button>
    `;
  } else {
    panel.innerHTML = `<button class="auth-btn google" onclick="signInWithGoogle()">üîë Sign In</button>`;
  }
}

async function saveGameResult(bet, win) {
  if (!currentUser || !userData) return;
  
  const userRef = db.collection('paddla_users').doc(currentUser.uid);
  await userRef.update({
    balance: balance,
    gamesPlayed: firebase.firestore.FieldValue.increment(1),
    totalWon: firebase.firestore.FieldValue.increment(win),
    totalBet: firebase.firestore.FieldValue.increment(bet)
  });
  
  await db.collection('paddla_games').add({
    userId: currentUser.uid,
    nickname: userData.nickname,
    bet,
    win,
    rtp: (win / bet * 100).toFixed(1),
    playedAt: firebase.firestore.FieldValue.serverTimestamp()
  });
}

const SERVER_URL = window.location.hostname === 'localhost' ? 'http://localhost:3000' : '';

// ===== AUDIO =====
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null, soundEnabled = false;

function initAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
function toggleSound() {
  initAudio(); soundEnabled = !soundEnabled;
  document.getElementById('soundBtn').textContent = soundEnabled ? 'üîä' : 'üîá';
  document.getElementById('soundBtn').classList.toggle('on', soundEnabled);
  if (soundEnabled) playTone(440, 0.1, 'sine', 0.2);
}
function playTone(freq, dur, type = 'sine', vol = 0.3) {
  if (!audioCtx || !soundEnabled) return;
  const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + dur);
}
function playGoal(prog) {
  const f = 400 + prog * 100;
  playTone(f, 0.1, 'square', 0.2);
  setTimeout(() => playTone(f * 1.5, 0.15, 'square', 0.2), 50);
  setTimeout(() => playTone(f * 2, 0.2, 'square', 0.25), 100);
}
function playExplosion() { for (let i = 0; i < 5; i++) setTimeout(() => playTone(100 + Math.random() * 200, 0.1, 'sawtooth', 0.15), i * 30); }
function playBounce() { playTone(300 + Math.random() * 200, 0.05, 'triangle', 0.1); }
function playRecharge() { playTone(600, 0.1, 'sine', 0.15); setTimeout(() => playTone(800, 0.1, 'sine', 0.15), 50); }
function playDouble() { playTone(500, 0.1, 'square', 0.2); setTimeout(() => playTone(700, 0.15, 'square', 0.25), 80); }
function playSpawn() { playTone(200, 0.08, 'sine', 0.1); }
function playTimeout() { playTone(150, 0.2, 'sawtooth', 0.15); setTimeout(() => playTone(100, 0.3, 'sawtooth', 0.1), 100); }
function playProgressiveReset() {
  [400, 300, 200, 100].forEach((f, i) => setTimeout(() => playTone(f, i === 3 ? 0.3 : 0.1, 'square', 0.2), i * 80));
}
function playGameOver(win) {
  if (win) [523, 659, 784, 1047].forEach((n, i) => setTimeout(() => playTone(n, 0.2, 'square', 0.2), i * 150));
  else { playTone(200, 0.3, 'sawtooth', 0.15); setTimeout(() => playTone(180, 0.3, 'sawtooth', 0.15), 300); setTimeout(() => playTone(160, 0.4, 'sawtooth', 0.12), 600); }
}

// ===== ENGINE =====
const FP_ROUND = 1e10;
function fpRound(v) { return Math.round(v * FP_ROUND) / FP_ROUND; }

class JavaRandom {
  constructor(seed) { this.seed = (BigInt(seed) ^ 0x5DEECE66Dn) & 0xFFFFFFFFFFFFn; }
  next(bits) { this.seed = (this.seed * 0x5DEECE66Dn + 0xBn) & 0xFFFFFFFFFFFFn; return Number(this.seed >> BigInt(48 - bits)); }
  nextDouble() { return (this.next(26) * 0x8000000 + this.next(27)) / 0x20000000000000; }
}

function dist(ax, ay, bx, by) { return Math.sqrt((bx-ax)**2 + (by-ay)**2); }
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

const CONFIG = {
  FIELD: 9, BALL_R: 0.2, SPEED: 0.05, GOAL_R: 1.02,
  CENTER_R: 0.225, CENTER_X: 4.5, CENTER_Y: 4.5, COUNTDOWN: 45,
  GOLDEN_CHANCE: 0.01, EXPLOSIVE_CHANCE: 1/75,
  SPAWN_COOLDOWN: 60, SPAWN_INTERVAL: 60, MAX_ON_FIELD: 10,
  TIMEOUT_LIMIT: 5, PROGRESSIVE_CAP: 5, BET_PER_BALL: 5, MAX_TICKS_PER_BALL: 600
};
const BUMPER = { RADIUS: 0.4, MIN_Y: 0.4, MAX_Y: 3.5, MIN_X: 1.5, MAX_X: 7.5, MAX_SPEED: 0.15, START_X: 4.5, START_Y: 2.0 };
const VALUE_COLORS = { 9:'#00ff00', 8:'#33ff00', 7:'#66ff00', 6:'#99ff00', 5:'#ccff00', 4:'#ffff00', 3:'#ffcc00', 2:'#ff9900', 1:'#ff6600', 0:'#ff0000' };

function isInLeftGoal(b) { return dist(b.x, b.y, 0, 0) < CONFIG.GOAL_R; }
function isInRightGoal(b) { return dist(b.x, b.y, CONFIG.FIELD, 0) < CONFIG.GOAL_R; }
function isGoal(b) { return isInLeftGoal(b) || isInRightGoal(b); }
function isInCenter(b) { return dist(b.x, b.y, CONFIG.CENTER_X, CONFIG.CENTER_Y) < CONFIG.CENTER_R + CONFIG.BALL_R; }
function isInUpperHalf(b) { return b.y < CONFIG.FIELD / 2; }

function createBall(rng, id) {
  const x = 0.5 + rng.nextDouble() * 8, y = CONFIG.FIELD - 0.3;
  const angle = (220 + rng.nextDouble() * 100) * Math.PI / 180;
  const typeRoll = rng.nextDouble();
  let type = 'normal', multiplier = 1;
  if (typeRoll < CONFIG.GOLDEN_CHANCE) { type = 'golden'; multiplier = 3; }
  else if (typeRoll < CONFIG.GOLDEN_CHANCE + CONFIG.EXPLOSIVE_CHANCE) { type = 'explosive'; }
  return { id, x, y, dx: Math.cos(angle) * CONFIG.SPEED, dy: Math.sin(angle) * CONFIG.SPEED, value: 9, ticksSinceCountdown: 0, alive: true, type, multiplier };
}

function randomizeBounce(ball, rng) {
  const angle = Math.atan2(ball.dy, ball.dx) + (rng.nextDouble() - 0.5) * 0.1 * Math.PI;
  const speed = Math.sqrt(ball.dx**2 + ball.dy**2);
  ball.dx = fpRound(Math.cos(angle) * speed);
  ball.dy = fpRound(Math.sin(angle) * speed);
}

function createBumper() { return { x: BUMPER.START_X, y: BUMPER.START_Y, targetX: BUMPER.START_X, targetY: BUMPER.START_Y }; }

function moveBumper(bumper) {
  const dx = bumper.targetX - bumper.x, dy = bumper.targetY - bumper.y;
  const d = Math.sqrt(dx*dx + dy*dy);
  if (d > BUMPER.MAX_SPEED) {
    bumper.x = fpRound(bumper.x + (dx/d) * BUMPER.MAX_SPEED);
    bumper.y = fpRound(bumper.y + (dy/d) * BUMPER.MAX_SPEED);
  } else { bumper.x = bumper.targetX; bumper.y = bumper.targetY; }
}

function collideBallBumper(ball, bumper, rng) {
  const d = dist(ball.x, ball.y, bumper.x, bumper.y);
  const minDist = CONFIG.BALL_R + BUMPER.RADIUS;
  if (d < minDist && d > 0) {
    const nx = (ball.x - bumper.x)/d, ny = (ball.y - bumper.y)/d;
    const dot = ball.dx*nx + ball.dy*ny;
    ball.dx = fpRound(ball.dx - 2*dot*nx); ball.dy = fpRound(ball.dy - 2*dot*ny);
    ball.x = fpRound(bumper.x + nx*minDist); ball.y = fpRound(bumper.y + ny*minDist);
    randomizeBounce(ball, rng);
    return true;
  }
  return false;
}

// ===== AI STRATEGIES =====
let hunterTargetId = null, defenderTargetId = null, sniperTargetId = null;

const STRATEGIES = {
  human: null,
  stationary: () => ({ x: BUMPER.START_X, y: BUMPER.START_Y }),
  hunter: (state) => {
    let target = state.balls.find(b => b.id === hunterTargetId && b.alive && b.y < CONFIG.FIELD/2);
    if (!target) {
      let best = -Infinity;
      for (const b of state.balls) {
        if (!b.alive || b.y > CONFIG.FIELD/2) continue;
        const score = (b.dy < 0 ? 100 : 0) + b.value*10 - b.y;
        if (score > best) { best = score; target = b; }
      }
      hunterTargetId = target?.id || null;
    }
    return target ? { x: clamp(target.x, BUMPER.MIN_X, BUMPER.MAX_X), y: clamp(target.y + 0.8, BUMPER.MIN_Y, BUMPER.MAX_Y) }
                  : { x: BUMPER.START_X, y: BUMPER.MAX_Y - 0.5 };
  },
  defender: (state) => {
    let target = state.balls.find(b => b.id === defenderTargetId && b.alive && b.y < CONFIG.FIELD/2);
    if (!target) {
      let best = -Infinity;
      for (const b of state.balls) {
        if (!b.alive || b.y >= CONFIG.FIELD/2) continue;
        const score = (b.dy > 0 ? 100 : 0) + b.value*b.multiplier*10 + (CONFIG.FIELD/2 - b.y);
        if (score > best) { best = score; target = b; }
      }
      defenderTargetId = target?.id || null;
    }
    if (!target) target = state.balls.find(b => b.alive);
    return target ? { x: clamp(target.x, BUMPER.MIN_X, BUMPER.MAX_X), y: clamp(target.y + 0.5, BUMPER.MIN_Y, BUMPER.MAX_Y) }
                  : { x: 4.5, y: 2.5 };
  },
  sniper: (state) => {
    let target = state.balls.find(b => b.id === sniperTargetId && b.alive && b.y < CONFIG.FIELD/2);
    if (!target) {
      let best = -Infinity;
      for (const b of state.balls) {
        if (!b.alive || b.y >= CONFIG.FIELD/2) continue;
        const score = b.value*b.multiplier*10 - b.y;
        if (score > best) { best = score; target = b; }
      }
      sniperTargetId = target?.id || null;
    }
    if (target) {
      const offsetX = target.x < 4.5 ? 0.5 : -0.5;
      return { x: clamp(target.x + offsetX, BUMPER.MIN_X, BUMPER.MAX_X), y: clamp(target.y + 0.3, BUMPER.MIN_Y, BUMPER.MAX_Y) };
    }
    return { x: 4.5, y: 2.0 };
  },
  random: (state, rng) => {
    if (state.tickCount % 30 === 0) return { x: BUMPER.MIN_X + rng.nextDouble()*(BUMPER.MAX_X-BUMPER.MIN_X), y: BUMPER.MIN_Y + rng.nextDouble()*(BUMPER.MAX_Y-BUMPER.MIN_Y) };
    return { x: state.bumper.targetX, y: state.bumper.targetY };
  },
  avoider: (state) => {
    let avgX = 0, avgY = 0, cnt = 0;
    for (const b of state.balls) { if (b.alive && b.y < CONFIG.FIELD/2) { avgX += b.x; avgY += b.y; cnt++; } }
    if (cnt) return { x: clamp(state.bumper.x + (state.bumper.x - avgX/cnt)*0.5, BUMPER.MIN_X, BUMPER.MAX_X), y: clamp(state.bumper.y + (state.bumper.y - avgY/cnt)*0.5, BUMPER.MIN_Y, BUMPER.MAX_Y) };
    return { x: BUMPER.START_X, y: BUMPER.START_Y };
  }
};

// ===== GAME STATE =====
let gameState = null, gameRunning = false, balance = 1000;
let currentMode = 'human', strategyRng = null, serverOnline = false;
let currentGameId = null, currentClientSeed = null, lastVerificationData = null;
let currentChunk = 0, lastChunkBalls = 0, chunkInputLog = [];
const CHUNK_SIZE = 50;
const floatingTexts = [], explosionParticles = [];
let goalFlashLeft = 0, goalFlashRight = 0;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const SCALE = canvas.width / CONFIG.FIELD;

let mouseX = BUMPER.START_X, mouseY = BUMPER.START_Y;
canvas.addEventListener('mousemove', (e) => { const r = canvas.getBoundingClientRect(); mouseX = (e.clientX-r.left)/SCALE; mouseY = (e.clientY-r.top)/SCALE; });
canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const r = canvas.getBoundingClientRect(); mouseX = (e.touches[0].clientX-r.left)/SCALE; mouseY = (e.touches[0].clientY-r.top)/SCALE; }, { passive: false });

document.getElementById('modeSelect').addEventListener('change', (e) => { currentMode = e.target.value; updateModeIndicator(); });

function updateModeIndicator() {
  const ind = document.getElementById('modeIndicator');
  const labels = { human:'üëÜ HUMAN', stationary:'üßç STATIONARY', hunter:'üéØ HUNTER', defender:'üõ°Ô∏è DEFENDER', sniper:'üî´ SNIPER', random:'üé≤ RANDOM', avoider:'üèÉ AVOIDER' };
  ind.textContent = labels[currentMode];
  ind.className = 'mode-indicator' + (currentMode === 'human' ? ' human' : '');
}

function updateProgressiveLamps(level) {
  document.querySelectorAll('.lamp').forEach((l, i) => l.classList.toggle('active', i < level));
}

function updateTimeoutDots(count) {
  document.querySelectorAll('.timeout-dot').forEach((d, i) => d.classList.toggle('active', i < count));
}

async function checkServer() {
  try {
    const res = await fetch(`${SERVER_URL}/commitment`);
    await res.json();
    serverOnline = true;
    document.getElementById('serverStatus').className = 'server-status online';
    document.getElementById('serverStatus').textContent = 'üü¢ Online';
  } catch { serverOnline = false; document.getElementById('serverStatus').className = 'server-status offline'; document.getElementById('serverStatus').textContent = '‚ö´ Offline'; }
}
checkServer(); setInterval(checkServer, 30000);

function createInitialState(seed, numBalls) {
  return { rng: new JavaRandom(seed), seed, balls: [], bumper: createBumper(), tickCount: 0, ballsSpawned: 0, numBalls, spawnCooldown: 0, progressive: 1, timeoutCount: 0, totalWin: 0, finished: false, nextBallId: 1, inputLog: [] };
}

function tick(state, skipInput = false) {
  if (state.finished) return [];
  const events = [];
  state.tickCount++;
  if (state.spawnCooldown > 0) state.spawnCooldown--;

  if (!skipInput) {
    if (currentMode === 'human') {
      state.bumper.targetX = clamp(mouseX, BUMPER.MIN_X, BUMPER.MAX_X);
      state.bumper.targetY = clamp(mouseY, BUMPER.MIN_Y, BUMPER.MAX_Y);
    } else {
      const strat = STRATEGIES[currentMode];
      if (strat) { const t = strat(state, strategyRng); state.bumper.targetX = clamp(t.x, BUMPER.MIN_X, BUMPER.MAX_X); state.bumper.targetY = clamp(t.y, BUMPER.MIN_Y, BUMPER.MAX_Y); }
    }
    const input = { tick: state.tickCount, target: { x: state.bumper.targetX, y: state.bumper.targetY } };
    state.inputLog.push(input);
    chunkInputLog.push(input);
  }
  moveBumper(state.bumper);

  if (state.tickCount % CONFIG.SPAWN_INTERVAL === 0 && state.balls.length < CONFIG.MAX_ON_FIELD && state.spawnCooldown <= 0 && state.ballsSpawned < state.numBalls) {
    const ball = createBall(state.rng, state.nextBallId++);
    state.balls.push(ball); state.ballsSpawned++; state.spawnCooldown = CONFIG.SPAWN_COOLDOWN;
    events.push({ type: 'spawn', ball });
  }

  for (const b of state.balls) {
    if (!b.alive) continue;
    b.ticksSinceCountdown++;
    b.x = fpRound(b.x + b.dx); b.y = fpRound(b.y + b.dy);
    const R = CONFIG.BALL_R, F = CONFIG.FIELD;
    if (b.x - R < 0) { b.x = R; b.dx = -b.dx; }
    if (b.x + R > F) { b.x = F - R; b.dx = -b.dx; }
    if (b.y - R < 0) { b.y = R; b.dy = -b.dy; }
    if (b.y + R > F) { b.y = F - R; b.dy = -b.dy; }
    if (b.type === 'normal' && b.ticksSinceCountdown >= CONFIG.COUNTDOWN && b.value > 0) {
      b.value--; b.ticksSinceCountdown = 0;
      if (b.value <= 0) { b.alive = false; b.diedFromTimeout = true; }
    }
    if (b.alive && (b.x - R < 0.01 || b.x + R > F - 0.01 || b.y - R < 0.01 || b.y + R > F - 0.01)) randomizeBounce(b, state.rng);
  }

  for (const b of state.balls) if (b.alive && collideBallBumper(b, state.bumper, state.rng)) events.push({ type: 'bumperHit', ball: b });

  for (const b of state.balls) {
    if (b.alive && isInCenter(b)) {
      const dx = b.x - CONFIG.CENTER_X, dy = b.y - CONFIG.CENTER_Y, d = Math.sqrt(dx*dx + dy*dy);
      if (d > 0) { b.dx = (dx/d)*CONFIG.SPEED; b.dy = (dy/d)*CONFIG.SPEED; randomizeBounce(b, state.rng); }
      if (b.type === 'normal' && b.value < 9) { b.value = 9; b.ticksSinceCountdown = 0; events.push({ type: 'recharge', ball: b }); }
    }
  }

  for (const ball of state.balls) {
    if (!ball.alive) continue;
    if (isGoal(ball)) {
      const prize = ball.value * ball.multiplier * state.progressive;
      state.totalWin += prize;
      if (ball.type === 'golden') state.timeoutCount = 0;
      if (state.progressive < CONFIG.PROGRESSIVE_CAP) state.progressive++;
      events.push({ type: 'goal', ball, prize, side: isInLeftGoal(ball) ? 'left' : 'right' });
      ball.alive = false;
      if (ball.type === 'explosive') {
        state.timeoutCount = 0;
        events.push({ type: 'explosion', ball, x: ball.x, y: ball.y });
        for (const o of state.balls) {
          if (o.alive && o.id !== ball.id && isInUpperHalf(o)) {
            const ep = o.value * o.multiplier * state.progressive;
            state.totalWin += ep;
            if (state.progressive < CONFIG.PROGRESSIVE_CAP) state.progressive++;
            events.push({ type: 'exploded', ball: o, prize: ep });
            o.alive = false;
          }
        }
      }
    }
  }

  for (let i = 0; i < state.balls.length; i++) {
    for (let j = i + 1; j < state.balls.length; j++) {
      const b1 = state.balls[i], b2 = state.balls[j];
      if (!b1.alive || !b2.alive) continue;
      if (dist(b1.x, b1.y, b2.x, b2.y) < CONFIG.BALL_R * 2) {
        const s1 = b1.type !== 'normal', s2 = b2.type !== 'normal';
        if (s1 && s2) {
          const dx = b2.x - b1.x, dy = b2.y - b1.y, d = Math.sqrt(dx*dx + dy*dy) || 1;
          const nx = dx/d, ny = dy/d, ov = CONFIG.BALL_R*2 - d;
          if (ov > 0) { b1.x -= nx*ov*0.5; b1.y -= ny*ov*0.5; b2.x += nx*ov*0.5; b2.y += ny*ov*0.5; }
          b1.dx = -nx*CONFIG.SPEED; b1.dy = -ny*CONFIG.SPEED;
          b2.dx = nx*CONFIG.SPEED; b2.dy = ny*CONFIG.SPEED;
          randomizeBounce(b1, state.rng); randomizeBounce(b2, state.rng);
          continue;
        }
        if (s1) { b2.alive = false; state.totalWin += 1; events.push({ type: 'collision', winner: b1, loser: b2, prize: 1 }); continue; }
        if (s2) { b1.alive = false; state.totalWin += 1; events.push({ type: 'collision', winner: b2, loser: b1, prize: 1 }); continue; }
        if (b1.value === b2.value) {
          const prize = b1.value * 2;
          state.totalWin += prize;
          events.push({ type: 'double', b1, b2, prize });
          if (state.rng.nextDouble() < 0.5) b2.alive = false; else b1.alive = false;
        } else {
          state.totalWin += 1;
          const loser = b1.value < b2.value ? b1 : b2, winner = b1.value < b2.value ? b2 : b1;
          loser.alive = false;
          const dx = winner.x - loser.x, dy = winner.y - loser.y, d = Math.sqrt(dx*dx + dy*dy) || 1;
          winner.dx = (dx/d)*CONFIG.SPEED; winner.dy = (dy/d)*CONFIG.SPEED;
          randomizeBounce(winner, state.rng);
          events.push({ type: 'collision', winner, loser, prize: 1 });
        }
      }
    }
  }

  for (const b of state.balls) {
    if (!b.alive && b.diedFromTimeout) {
      state.timeoutCount++;
      events.push({ type: 'timeout', ball: b });
      if (state.timeoutCount >= CONFIG.TIMEOUT_LIMIT) {
        state.progressive = 1; state.timeoutCount = 0;
        events.push({ type: 'progressiveReset' });
      }
      b.diedFromTimeout = false;
    }
  }

  state.balls = state.balls.filter(b => b.alive);

  if (state.balls.length > 0 && !state.balls.some(b => b.type === 'normal')) {
    for (const b of state.balls) {
      if (b.alive) {
        const prize = b.value * b.multiplier * state.progressive;
        state.totalWin += prize;
        if (state.progressive < CONFIG.PROGRESSIVE_CAP) state.progressive++;
        events.push({ type: 'autoCollect', ball: b, prize });
        b.alive = false;
      }
    }
    state.balls = [];
  }

  if (state.ballsSpawned >= state.numBalls && state.balls.length === 0) {
    state.finished = true;
    events.push({ type: 'gameEnd', totalWin: state.totalWin });
  }

  return events;
}

// ===== RENDERING =====
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const la = 0.3 + goalFlashLeft * 0.5, ra = 0.3 + goalFlashRight * 0.5;
  ctx.fillStyle = `rgba(0,255,100,${la})`; ctx.beginPath(); ctx.arc(0, 0, CONFIG.GOAL_R * SCALE, 0, Math.PI/2); ctx.lineTo(0, 0); ctx.fill();
  ctx.fillStyle = `rgba(0,255,100,${ra})`; ctx.beginPath(); ctx.arc(canvas.width, 0, CONFIG.GOAL_R * SCALE, Math.PI/2, Math.PI); ctx.lineTo(canvas.width, 0); ctx.fill();
  ctx.strokeStyle = '#00ff66'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0, 0, CONFIG.GOAL_R * SCALE, 0, Math.PI/2); ctx.stroke();
  ctx.beginPath(); ctx.arc(canvas.width, 0, CONFIG.GOAL_R * SCALE, Math.PI/2, Math.PI); ctx.stroke();
  
  ctx.fillStyle = 'rgba(0,200,255,0.2)'; ctx.beginPath(); ctx.arc(CONFIG.CENTER_X * SCALE, CONFIG.CENTER_Y * SCALE, CONFIG.CENTER_R * SCALE, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#00d4ff'; ctx.stroke();
  
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(BUMPER.MIN_X * SCALE, BUMPER.MIN_Y * SCALE, (BUMPER.MAX_X - BUMPER.MIN_X) * SCALE, (BUMPER.MAX_Y - BUMPER.MIN_Y) * SCALE);
  
  for (const p of explosionParticles) {
    ctx.fillStyle = `rgba(255,${150+Math.random()*100|0},0,${p.life})`;
    ctx.beginPath(); ctx.arc(p.x * SCALE, p.y * SCALE, p.size * SCALE, 0, Math.PI*2); ctx.fill();
  }
  
  if (gameState) {
    ctx.fillStyle = '#00d4ff'; ctx.shadowColor = '#00d4ff'; ctx.shadowBlur = 15;
    ctx.beginPath(); ctx.arc(gameState.bumper.x * SCALE, gameState.bumper.y * SCALE, BUMPER.RADIUS * SCALE, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0; ctx.fillStyle = '#004466';
    ctx.beginPath(); ctx.arc(gameState.bumper.x * SCALE, gameState.bumper.y * SCALE, BUMPER.RADIUS * SCALE * 0.6, 0, Math.PI*2); ctx.fill();
    
    for (const b of gameState.balls) {
      if (!b.alive) continue;
      let color, glow;
      if (b.type === 'golden') { color = '#ffa500'; glow = '#ff8c00'; }
      else if (b.type === 'explosive') { color = '#ff4444'; glow = '#ff0000'; }
      else { color = VALUE_COLORS[b.value] || '#fff'; glow = color; }
      ctx.shadowColor = glow; ctx.shadowBlur = 12; ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(b.x * SCALE, b.y * SCALE, CONFIG.BALL_R * SCALE, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = b.type === 'explosive' ? '#fff' : '#000';
      ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      if (b.type === 'normal') ctx.fillText(b.value, b.x * SCALE, b.y * SCALE);
      else if (b.type === 'golden') ctx.fillText('G', b.x * SCALE, b.y * SCALE);
      else ctx.fillText('üí•', b.x * SCALE, b.y * SCALE);
    }
  }
  
  if (gameRunning && currentMode === 'human') {
    ctx.strokeStyle = 'rgba(0,212,255,0.4)'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.arc(clamp(mouseX, BUMPER.MIN_X, BUMPER.MAX_X) * SCALE, clamp(mouseY, BUMPER.MIN_Y, BUMPER.MAX_Y) * SCALE, BUMPER.RADIUS * SCALE, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
  }
  
  for (const ft of floatingTexts) {
    ctx.save(); ctx.globalAlpha = ft.opacity; ctx.fillStyle = ft.color;
    ctx.font = `bold ${ft.size||16}px Arial`; ctx.textAlign = 'center';
    ctx.shadowColor = ft.color; ctx.shadowBlur = 10;
    ctx.fillText(ft.text, ft.x, ft.y); ctx.restore();
  }
}

function showFloatingText(x, y, text, color, size = 16) { floatingTexts.push({ x: x * SCALE, y: y * SCALE, text, color, opacity: 1, dy: -2, size }); }
function createExplosion(x, y) { for (let i = 0; i < 20; i++) { const a = Math.random() * Math.PI * 2, s = 0.05 + Math.random() * 0.1; explosionParticles.push({ x, y, dx: Math.cos(a)*s, dy: Math.sin(a)*s, life: 1, size: 0.1 + Math.random()*0.15 }); } }

function updateEffects() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) { floatingTexts[i].y += floatingTexts[i].dy; floatingTexts[i].opacity -= 0.025; if (floatingTexts[i].opacity <= 0) floatingTexts.splice(i, 1); }
  for (let i = explosionParticles.length - 1; i >= 0; i--) { explosionParticles[i].x += explosionParticles[i].dx; explosionParticles[i].y += explosionParticles[i].dy; explosionParticles[i].life -= 0.03; if (explosionParticles[i].life <= 0) explosionParticles.splice(i, 1); }
  goalFlashLeft *= 0.9; goalFlashRight *= 0.9;
}

function updateUI() {
  if (gameState) {
    document.getElementById('ballsLeft').textContent = gameState.numBalls - gameState.ballsSpawned + gameState.balls.length;
    document.getElementById('winDisplay').textContent = '$' + gameState.totalWin;
    updateProgressiveLamps(gameState.progressive);
    updateTimeoutDots(gameState.timeoutCount);
  }
  document.getElementById('balance').textContent = '$' + balance;
}

function gameLoop() {
  if (gameRunning && gameState && !gameState.finished) {
    const events = tick(gameState);
    for (const e of events) {
      if (e.type === 'goal') { showFloatingText(e.ball.x, e.ball.y, '+' + e.prize, '#00ff66', 20); if (e.side === 'left') goalFlashLeft = 1; else goalFlashRight = 1; playGoal(gameState.progressive); }
      if (e.type === 'explosion') { createExplosion(e.x, e.y); playExplosion(); }
      if (e.type === 'exploded') { showFloatingText(e.ball.x, e.ball.y, '+' + e.prize, '#ff6600', 18); }
      if (e.type === 'double') { showFloatingText((e.b1.x + e.b2.x)/2, (e.b1.y + e.b2.y)/2, 'DOUBLE +' + e.prize, '#ffd700', 22); playDouble(); }
      if (e.type === 'timeout') { showFloatingText(e.ball.x, e.ball.y, '‚úó', '#ff4444'); playTimeout(); }
      if (e.type === 'progressiveReset') { showFloatingText(4.5, 2, 'RESET √ó1', '#ff4444', 24); playProgressiveReset(); updateTimeoutDots(5); setTimeout(() => updateTimeoutDots(0), 500); }
      if (e.type === 'spawn') { 
        playSpawn();
        const ballsPlayed = gameState.ballsSpawned;
        if (ballsPlayed - lastChunkBalls >= CHUNK_SIZE && serverOnline && currentGameId) {
          sendChunk(currentGameId, currentChunk, chunkInputLog, ballsPlayed);
          currentChunk++;
          lastChunkBalls = ballsPlayed;
          chunkInputLog = [];
        }
      }
      if (e.type === 'autoCollect') { showFloatingText(e.ball.x, e.ball.y, 'üí´ +' + e.prize, '#ffaa00', 20); createExplosion(e.ball.x, e.ball.y); playGoal(gameState.progressive); }
      if (e.type === 'collision' && e.prize > 1) { showFloatingText(e.loser.x, e.loser.y, '+' + e.prize, '#ffff00'); }
      if (e.type === 'recharge') { playRecharge(); }
      if (e.type === 'bumperHit') { playBounce(); }
      if (e.type === 'gameEnd') {
        gameRunning = false;
        document.getElementById('playBtn').disabled = false;
        document.getElementById('modeSelect').disabled = false;
        document.getElementById('finalWin').textContent = gameState.totalWin;
        const bet = gameState.numBalls * CONFIG.BET_PER_BALL, rtp = gameState.totalWin / bet;
        document.getElementById('finalRtp').textContent = `Bet: ${bet} | RTP: ${(rtp * 100).toFixed(1)}%`;
        playGameOver(rtp >= 1);
        
        balance += gameState.totalWin;
        saveGameResult(bet, gameState.totalWin);
        updateAuthUI();
        
        if (lastVerificationData && serverOnline) {
          document.getElementById('vGameId').textContent = lastVerificationData.gameId;
          document.getElementById('vClientSeed').textContent = lastVerificationData.clientSeed;
          document.getElementById('vCommitment').textContent = lastVerificationData.commitment;
          document.getElementById('vServerSeed').textContent = 'Verifying...';
          document.getElementById('verifyBtn').disabled = true;
          document.getElementById('verifySection').style.display = 'block';
          (async () => {
            try {
              if (chunkInputLog.length > 0) {
                await sendChunk(currentGameId, currentChunk, chunkInputLog, gameState.ballsSpawned);
              }
              const result = await finishGameOnServer(lastVerificationData.gameId, gameState.totalWin);
              if (result.verified) {
                document.getElementById('vServerSeed').textContent = result.serverSeed;
                lastVerificationData.serverSeed = result.serverSeed;
                lastVerificationData.gameSeedHex = result.gameSeedHex;
                document.getElementById('verifyBtn').disabled = false;
              } else {
                document.getElementById('vServerSeed').textContent = 'VERIFICATION FAILED!';
                document.getElementById('vServerSeed').style.color = '#ff4444';
              }
            } catch (err) {
              console.error('Verification error:', err);
              document.getElementById('vServerSeed').textContent = 'Error: ' + err.message;
            }
          })();
        } else document.getElementById('verifySection').style.display = 'none';
        document.getElementById('result').classList.add('show');
      }
    }
    updateUI();
  }
  updateEffects(); render(); requestAnimationFrame(gameLoop);
}

async function sendChunk(gameId, chunkNum, inputLog, ballsPlayed) {
  try {
    await fetch(`${SERVER_URL}/game/${gameId}/chunk`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chunkNum, inputLog, ballsPlayed })
    });
  } catch (err) {
    console.error('Chunk send failed:', err);
  }
}

async function finishGameOnServer(gameId, clientTotalWin) {
  try {
    const res = await fetch(`${SERVER_URL}/game/${gameId}/finish`, { 
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify({ clientTotalWin }) 
    });
    const data = await res.json();
    if (data.verified) {
      return { verified: true, serverSeed: data.verification.serverSeed, gameSeedHex: data.verification.gameSeedHex };
    } else {
      return { verified: false };
    }
  } catch (err) {
    console.error('Finish failed:', err);
    return { verified: false };
  }
}

document.getElementById('verifyBtn').addEventListener('click', async () => {
  if (!lastVerificationData?.serverSeed) { document.getElementById('verifyResult').innerHTML = '<span style="color:#ff4444">‚ùå No data</span>'; return; }
  const vd = lastVerificationData;
  try {
    const enc = new TextEncoder();
    const hash = await crypto.subtle.digest('SHA-256', enc.encode(vd.serverSeed));
    const commitment = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
    if (commitment !== vd.commitment) { document.getElementById('verifyResult').innerHTML = '<span style="color:#ff4444">‚ùå Commitment mismatch!</span>'; return; }
    const key = await crypto.subtle.importKey('raw', enc.encode(vd.serverSeed), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
    const sig = await crypto.subtle.sign('HMAC', key, enc.encode(vd.clientSeed + ':' + vd.gameId));
    const gameSeedHex = Array.from(new Uint8Array(sig)).map(b => b.toString(16).padStart(2, '0')).join('');
    if (gameSeedHex !== vd.gameSeedHex) { document.getElementById('verifyResult').innerHTML = '<span style="color:#ff4444">‚ùå Seed mismatch!</span>'; return; }
    document.getElementById('verifyResult').innerHTML = '<span style="color:#00ff66">‚úì VERIFIED!</span>';
  } catch { document.getElementById('verifyResult').innerHTML = '<span style="color:#ff4444">‚ùå Error</span>'; }
});

document.getElementById('playBtn').addEventListener('click', async () => {
  initAudio();
  const numBalls = parseInt(document.getElementById('ballCount').value) || 100;
  const bet = numBalls * CONFIG.BET_PER_BALL;
  if (bet > balance) { alert('Insufficient balance!'); return; }
  balance -= bet;
  currentClientSeed = 'client_' + Date.now() + '_' + Math.random().toString(36).substring(2, 10);
  lastVerificationData = null;
  let gameSeed;
  if (serverOnline) {
    try {
      const res = await fetch(`${SERVER_URL}/game/start`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ clientSeed: currentClientSeed, numBalls }) });
      const data = await res.json();
      currentGameId = data.gameId;
      lastVerificationData = { gameId: data.gameId, clientSeed: currentClientSeed, commitment: data.commitment };
      gameSeed = parseInt(data.gameSeedHex, 16);
    } catch { gameSeed = Math.floor(Date.now() / 1000); }
  } else gameSeed = Math.floor(Date.now() / 1000);
  strategyRng = new JavaRandom(gameSeed + 999999);
  hunterTargetId = defenderTargetId = sniperTargetId = null;
  gameState = createInitialState(gameSeed, numBalls);
  gameRunning = true;
  currentChunk = 0;
  lastChunkBalls = 0;
  chunkInputLog = [];
  updateTimeoutDots(0);
  document.getElementById('playBtn').disabled = true;
  document.getElementById('modeSelect').disabled = true;
  document.getElementById('result').classList.remove('show');
  updateUI();
});

document.getElementById('autoBtn').addEventListener('click', async () => {
  const numBalls = parseInt(document.getElementById('ballCount').value) || 100;
  const strategies = ['stationary', 'hunter', 'defender', 'sniper', 'random', 'avoider'];
  const results = {}; strategies.forEach(s => results[s] = { rtps: [] });
  document.getElementById('autoResults').classList.add('show');
  document.getElementById('autoTable').innerHTML = '';
  const baseSeed = Math.floor(Date.now() / 1000);
  for (let run = 0; run < 10; run++) {
    document.getElementById('autoProgress').textContent = `Running... ${run + 1}/10`;
    await new Promise(r => setTimeout(r, 10));
    for (const strat of strategies) {
      const result = simulateStrategy(baseSeed + run, numBalls, strat);
      results[strat].rtps.push(result.totalWin / (numBalls * CONFIG.BET_PER_BALL) * 100);
    }
  }
  const stats = strategies.map(s => { const rtps = results[s].rtps; return { strat: s, avg: rtps.reduce((a,b)=>a+b,0)/rtps.length, min: Math.min(...rtps), max: Math.max(...rtps) }; }).sort((a,b) => b.avg - a.avg);
  const labels = { stationary: 'üßç', hunter: 'üéØ', defender: 'üõ°Ô∏è', sniper: 'üî´', random: 'üé≤', avoider: 'üèÉ' };
  let html = '<tr><th></th><th>Avg</th><th>Min</th><th>Max</th></tr>';
  stats.forEach((s, i) => { html += `<tr class="${i === 0 ? 'best' : i === stats.length - 1 ? 'worst' : ''}"><td>${labels[s.strat]} ${s.strat}</td><td>${s.avg.toFixed(1)}%</td><td>${s.min.toFixed(0)}%</td><td>${s.max.toFixed(0)}%</td></tr>`; });
  document.getElementById('autoProgress').textContent = `10 runs √ó ${numBalls} balls`;
  document.getElementById('autoTable').innerHTML = html;
});

document.getElementById('autoClose').addEventListener('click', () => document.getElementById('autoResults').classList.remove('show'));

function simulateStrategy(seed, numBalls, strategyName) {
  const state = createInitialState(seed, numBalls);
  const stratRng = new JavaRandom(seed + 999999);
  const strategy = STRATEGIES[strategyName];
  hunterTargetId = defenderTargetId = sniperTargetId = null;
  let ticks = 0;
  while (!state.finished && ticks < numBalls * CONFIG.MAX_TICKS_PER_BALL) {
    if (strategy) { const t = strategy(state, stratRng); state.bumper.targetX = clamp(t.x, BUMPER.MIN_X, BUMPER.MAX_X); state.bumper.targetY = clamp(t.y, BUMPER.MIN_Y, BUMPER.MAX_Y); }
    tick(state, true); ticks++;
  }
  return { totalWin: state.totalWin };
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.getElementById('result').classList.remove('show');
    document.getElementById('autoResults').classList.remove('show');
  }
});

updateModeIndicator(); updateProgressiveLamps(1); render(); gameLoop();
</script>
</body>
</html>
